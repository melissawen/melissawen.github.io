# Tips for debugging issues in the AMD display kernel driver

This blog post contain some tips for examining and debugging the AMD display driver in the Linux kernel/DRM subsystem.
Worth to mention that it's in the same context of my talk in 2022 XDC, "I'm not an AMD expert, but..." and I share here guidelines that helped me debugging AMD display issues as an external developer of the driver.
I collected these tips thanks to the countless assistance I received from AMD developers during the driver development. In short, examining the open source code, public documentation, playing with tools, Q&A and chats with Rodrigo Siqueira. 

Linux AMD GPU driver has an issue tracker [here](https://gitlab.freedesktop.org/drm/amd/-/issues). The AMD/Linux kernel display driver is open source, therefore, taking a problem from this list to solve or solving your own driver problems can be quite an adventure and also a good community contribution. Moreover, when debugging an issue, the issue tracker can be useful to find similar bugs and also some debugging tips and suggestions from AMD developers (the real experts). Finally, it's also a good forum to ask for help.

- Now, let's start?!
- But from where?

Before start debugging, there is an important pre-debugging step: check if the issue is currently present with a kernel from `amd-staging-drm-next`.

### Is it an AMD kernel driver issue?

This is the first question regardless GPU vendors! But sometimes it's hard to determine.

1. Record the screen using a recorder screen app (in your buggy device) when you see the issue, if the bug appears in your capture, the issue might be in the userspace, not in the kernel display driver.
- The idea behind it is that screen captures take the frame buffer created by userspace before submit to the kernel, if the issue already appear there, the kernel display machinery have not affected the output yet.

2. Looking for a clue in the dmesg log. Where is the error message?
- It isn't a display issue if the error on dmesg is placing before this message: `[drm] amdgpu kernel modesetting enabled.`

### Should I focus on which part of the AMD display code: AMD Display Manager (the Linux-dependent part) or AMD Display Core (the OS-agnostic part)?

1. AMD Display Manager (DM) is the layer of AMD display driver that directly interacts with the Linux DRM infrastructure.
  - Sometimes the issue is around a DRM property or a feature of a DRM component that is not mapped correctly by AMD DM. Also, if you have the chance to test the hardware on other platforms and it's working well, great chances to having an issue in this portion of the code.
  - Obs: Changes here is easier to be accepted since this is used only by the Linux kernel.
2. AMD Display Core (DC) is the shared-code portion of AMD display driver, closer to the HW registers.
  - This is used by multiple platforms to set/program all hardware features.
  - Obs: Changes here usually need validation in other platforms and may not be accepted if it causes a regression there. 

### Check relevant code for a DC HW family

Every ASIC has variations around this base model. Features and helpers change between HW families, you should determine the relevant code for validations. On the other hand, a new driver version can inherits the implementation of the previous one. You can use two different HW families to compare behaviours. If you see the issue in one but not in the other, you can compare the code and understand what has changed and if the implementation from a previous family doesn't fit well the new HW resources or design.

1. Find GPU product information at: https://dri.freedesktop.org/docs/drm/gpu/amdgpu/driver-misc.html#gpu-product-information
2. Since [`bf7fda0b3736 drm/amd/display: Show the DCN/DCE version in the log`](https://github.com/torvalds/linux/commit/bf7fda0b3736f93ac8b18e7147e1e7acd27e6a19) in mainline kernel 6.3v, you can find the Display Core version in the dmesg, such as:
  - `[drm] Display Core v3.2.241 initialized on DCN 2.1`
  - `[drm] Display Core v3.2.237 initialized on DCN 3.0.1`

After knowing the AMD DCN driver of the hardware, you can start the driver code inspection with better accuracy.

1. In a Linux kernel branch, you will find relevant code in a directory at `drivers/gpu/drm/amd/display/dc` that the name is the DC number of the HW. For example, driver specific code for `DCN 3.0.1` resides in `drm/gpu/amd/display/dc/dcn301`, that is the Steam Deck display driver.

2. As I mentioned before, newer families may inherit older (lower number of) families implementations/features, an example is the [color correction caps](https://dri.freedesktop.org/docs/drm/gpu/amdgpu/display/display-manager.html#dc-color-capabilities-between-dcn-generations). Therefore, you can find dcn301 using code from dcn30/dcn20/dcn10. You should check which hooks/helpers your driver is using to investigate the right portion of the code, you can also use `ftrace` for additional validation.

### Try to understand the history around the issue

Latest AMD driver changes reside on [`amd-staging-drm-next`](https://gitlab.freedesktop.org/agd5f/linux/-/tree/amd-staging-drm-next) branch, maintained by Alex Deucher. You may also find some bug fixes on branches like `drm-fixes-` in this same repository that targets kernel versions newer than one that `amd-staging-drm-next` is based.

1. Look for keywords in the `git log` targeting the relevant portion of you code.
2. If you are examining the `amd-staging-drm-next`, check for regressions between DC release versions. DC release version is defined by [`DC_VER`](https://gitlab.freedesktop.org/agd5f/linux/-/blob/amd-staging-drm-next/drivers/gpu/drm/amd/display/dc/dc.h#L48) on `dc.h` file. You can also find a commit with this format `drm/amd/display: 3.2.221` that determine a display release. It's useful for bisecting. It also helps you to get an idea of how outdated is your branch since you can consider each version takes around one week to be updated.

### Validations

KMD issues may not display any error/warning on dmesg log, so you try to reduce the problem and event check if the it's a KMD, UMD or app issue, for example. Depending on your issue, you may want to perform some validations:
1. Try to identify the HW blocks involved in your issue. You can find more about DCN HW blocks in the [DCN Overview documentation](https://dri.freedesktop.org/docs/drm/gpu/amdgpu/display/dcn-overview.html).
  - Plane issues are closer to HUBP and DPP.
  - Blending/Stream issues are closer to MPC, OPP and OPTC. They are related to DRM CRTC subjects.
  - Issues around bandwidth and clocks may be affect by calculations done in these HW blocks and HW specific values. The recalculation equations are found in the DML folder. Finding some clk variables that affect the device behavior may be a sign of it. It's hard for a external developer debug this part, since it involves information from HW specs and firmware programming. The best option is to provide all relevant debugging information you have and ask AMD developers to check the values from your suspicious.
    - Try to change the power performance and see if it affects the system behavior:
      - `sudo bash -c "echo high > /sys/class/drm/card0/device/power_dpm_force_performance_level"`
2. Use debugging tools to understand your driver settings and check the behavior when changing the settings. You can use:
  - [DC Visual confirmation](https://dri.freedesktop.org/docs/drm/gpu/amdgpu/display/dc-debug.html#dc-visual-confirmation): check multiple planes and pipe split policy
  - [DTN logs](https://dri.freedesktop.org/docs/drm/gpu/amdgpu/display/dc-debug.html#dtn-debug): check display hardware state, such as rotation, size, format, underflow, blocks in use, color block values, pixel blend modes, etc.
  - [UMR](https://gitlab.freedesktop.org/tomstdenis/umr): check ASIC info, register values, KMS state - links and elements (framebuffers, planes, CRTCs, connectors).

3. Check if the selected type for atomic update may affect your issue. The update type depends on the mode settings, since programming some modes demands more time for hardware processing. More information [source](https://cgit.freedesktop.org/drm/drm-misc/tree/drivers/gpu/drm/amd/display/dc/dc.h):
```
/* Surface update type is used by dc_update_surfaces_and_stream
 * The update type is determined at the very beginning of the function based
 * on parameters passed in and decides how much programming (or updating) is
 * going to be done during the call.
 *
 * UPDATE_TYPE_FAST is used for really fast updates that do not require much
 * logical calculations or hardware register programming. This update MUST be
 * ISR safe on windows. Currently fast update will only be used to flip surface
 * address.
 *
 * UPDATE_TYPE_MED is used for slower updates which require significant hw
 * re-programming however do not affect bandwidth consumption or clock
 * requirements. At present, this is the level at which front end updates
 * that do not require us to run bw_calcs happen. These are in/out transfer func
 * updates, viewport offset changes, recout size changes and pixel depth changes.
 * This update can be done at ISR, but we want to minimize how often this happens.
 *
 * UPDATE_TYPE_FULL is slow. Really slow. This requires us to recalculate our
 * bandwidth and clocks, possibly rearrange some pipes and reprogram anything front
 * end related. Any time viewport dimensions, recout dimensions, scaling ratios or
 * gamma need to be adjusted or pipe needs to be turned on (or disconnected) we do
 * a full update. This cannot be done at ISR level and should be a rare event.
 * Unless someone is stress testing mpo enter/exit, playing with colour or adjusting
 * underscan we don't expect to see this call at all.
 */

enum surface_update_type {
	UPDATE_TYPE_FAST, /* super fast, safe to execute in isr */
	UPDATE_TYPE_MED,  /* ISR safe, most of programming needed, no bw/clk change*/
	UPDATE_TYPE_FULL, /* may need to shuffle resources */
};
```

### Use DRM/KMS debugging tools

- IGT test tools
Some issues are an accumulation of bugs across the Linux display stack. Isolating your issue in the kernel space from others in the userspace can be useful. For this, you can use existing generic KMS tests available in the IGT test tools, or developing a new test case that cover the problem you want to solve. Generic KMS tests in IGT also help on testing with different GPU vendors to understand how each driver deals with it. By comparing results you can find the solution in another driver implementation or, at least, get some ideas of what can be broken in your driver. Besides that, AMD has specific IGT tests for its GPUs that is expect to work without failures on any AMD GPU. You can check results of HW-specific tests using different display hardware families or you can compare expected differences between the generic workflow and AMD workflow.

- drm_info
This tool summarizes the current state of a display driver (capabilities, properties and formats) per element of the DRM/KMS workflow (Plane, CRTC, encoder and connector). `drm_info` outputs are also useful when reporting bugs.
